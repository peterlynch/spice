diff -urwN guice-trunk/build.properties guice-patches-2.1.1/build.properties
--- guice-trunk/build.properties	2009-10-20 16:02:21.673071000 +0800
+++ guice-patches-2.1.1/build.properties	2010-01-11 16:22:45.723658000 +0800
@@ -10,7 +10,7 @@
 multibindings.src.dir=extensions/multibindings/src
 privatemodules.src.dir=extensions/privatemodules/src
 lifecycle.src.dir=lifecycle/src
-build.dir=build
+build.dir=target
 javadoc.packagenames=com.google.inject,com.google.inject.spi,\
   com.google.inject.matcher,\
   com.google.inject.servlet,\
@@ -26,4 +26,7 @@
   com.google.inject.util
 test.class=com.google.inject.AllTests
 module=com.google.inject
-exclude.imports: !net.sf.cglib.*,!org.objectweb.asm.*
+imports=!net.sf.cglib.*,!org.objectweb.asm.*
+
+Bundle-Vendor: Sonatype Inc.
+Bundle-SymbolicName: org.sonatype.spice.inject.guice-patches
diff -urwN guice-trunk/build.xml guice-patches-2.1.1/build.xml
--- guice-trunk/build.xml	2009-10-20 16:02:21.673071000 +0800
+++ guice-patches-2.1.1/build.xml	2010-01-11 14:03:24.283569000 +0800
@@ -2,9 +2,6 @@
 
 <project name="guice" default="compile">
 
-  <property name="DynamicImport-Package" value="org.aopalliance.intercept"/>
-  <property name="exclude.imports" value="!com.google.common.*,!net.sf.*,!org.objectweb.*"/>
-
   <import file="common.xml"/>
 
   <path id="compile.classpath">
@@ -12,7 +9,6 @@
     <fileset dir="${lib.dir}/build" includes="*.jar"/>
   </path>
 
-
   <target name="jar" depends="jar.withdeps, manifest" description="Build jar.">
     <jar jarfile="${build.dir}/dist/guice-${version}.jar"
         manifest="${build.dir}/META-INF/MANIFEST.MF">
@@ -90,10 +86,15 @@
         <pathelement location="lib/build/easymock.jar"/>
         <pathelement location="lib/javax.inject.jar"/>
         <pathelement location="lib/build/javax.inject-tck.jar"/>
+        <pathelement location="lib/build/bnd-0.0.384.jar"/>
+        <pathelement location="lib/build/felix-2.0.2.jar"/>
       </classpath>
       <arg value="com.google.inject.AllTests"/>    
       <syspropertyset>
         <propertyref name="guice.custom.loader"/>
+        <propertyref name="version"/>
+        <propertyref name="build.dir"/>
+        <propertyref name="lib.dir"/>
       </syspropertyset>
     </java>
   </target>
@@ -108,6 +109,7 @@
          windowtitle="Guice ${version} API">
       <sourcepath>
         <pathelement location="${src.dir}"/>
+<!--
         <pathelement location="${servlet.src.dir}"/>
         <pathelement location="${spring.src.dir}"/>
         <pathelement location="${assistedinject.src.dir}"/>
@@ -116,14 +118,20 @@
         <pathelement location="${throwingproviders.src.dir}"/>
         <pathelement location="${multibindings.src.dir}"/>
         <pathelement location="${lifecycle.src.dir}"/>
+-->
       </sourcepath>
       <classpath refid="compile.classpath"/>
+<!--
       <classpath>
         <fileset dir="servlet/lib/build" includes="*.jar"/>
       </classpath>
+-->
+      <link href="http://atinject.googlecode.com/svn/tags/1/javadoc"/>
       <link href="http://aopalliance.sourceforge.net/doc"/>
       <link href="http://java.sun.com/javase/6/docs/api"/>
+<!--
       <link href="http://www.springframework.org/docs/api/"/>
+-->
     </javadoc>
     <!-- generate core javadocs, used only for its left-side nav -->
     <mkdir dir="${build.dir}/javadoc-core"/>
@@ -134,6 +142,7 @@
          windowtitle="Guice ${version} Core API"
          sourcepath="${src.dir}">
       <classpath refid="compile.classpath"/>
+      <link href="http://atinject.googlecode.com/svn/tags/1/javadoc"/>
       <link href="http://aopalliance.sourceforge.net/doc"/>
       <link href="http://java.sun.com/javase/6/docs/api"/>
     </javadoc>
diff -urwN guice-trunk/common.xml guice-patches-2.1.1/common.xml
--- guice-trunk/common.xml	2009-12-30 09:05:45.216587000 +0800
+++ guice-patches-2.1.1/common.xml	2010-01-08 17:29:42.583128000 +0800
@@ -25,13 +25,14 @@
   <target name="manifest" description="Generate OSGi manifest." depends="compile">
     <dirname property="common.basedir" file="${ant.file.common}"/>
     <taskdef resource="aQute/bnd/ant/taskdef.properties"
-      classpath="${common.basedir}/lib/build/bnd-0.0.305.jar"/>
+      classpath="${common.basedir}/lib/build/bnd-0.0.384.jar"/>
 
     <fail unless="module" message="Missing 'module' property (use the primary package name in this jar)"/>
+    <property name="imports" value=""/>
 
     <property name="Bundle-Name" value="${ant.project.name}"/>
     <property name="Bundle-SymbolicName" value="${module}"/>
-    <property name="Bundle-Version" value="${replace;${version};^[^0-9];${api.version}.$0}"/>
+    <property name="Bundle-Version" value="${replace;${version};^[^0-9];0.0.0.$0}"/>
 
     <property name="Bundle-Description" value="Guice is a lightweight dependency injection framework for Java 5 and above"/>
     <property name="Bundle-DocURL" value="http://code.google.com/p/google-guice/"/>
@@ -39,12 +40,18 @@
     <property name="Bundle-License" value="http://www.apache.org/licenses/LICENSE-2.0"/>
     <property name="Bundle-Vendor" value="Google Inc."/>
 
-    <property name="exclude.imports" value=""/>
-    <property name="api.range" value="&quot;[${api.version},${version;+;${api.version}})&quot;"/>
-    <property name="guice.imports" value="com.google.inject.*;version=${api.range}"/>
-    <property name="Import-Package" value="${exclude.imports},${guice.imports},*;resolution:=optional"/>
     <property name="Export-Package" value="!${module}.internal.*,${module}.*;version=${api.version}"/>
 
+    <condition property="Import-Package" value="!com.google.inject.*,*" else="!${module}.*,${imports},*">
+      <istrue value="${fragment}"/>
+    </condition>
+
+    <condition property="Fragment-Host" value="com.google.inject">
+      <istrue value="${fragment}"/>
+    </condition>
+
+    <property name="-nouses" value="true"/>
+
     <property name="-removeheaders" value="Bnd-LastModified,Ignore-Package,Include-Resource,Private-Package,Tool"/>
 
     <bndwrap jars="${build.dir}/classes" output="${build.dir}"/>
diff -urwN guice-trunk/src/com/google/inject/Injector.java guice-patches-2.1.1/src/com/google/inject/Injector.java
--- guice-trunk/src/com/google/inject/Injector.java	2010-02-14 00:16:44.563660000 +0800
+++ guice-patches-2.1.1/src/com/google/inject/Injector.java	2009-12-16 01:32:52.779554000 +0800
@@ -20,6 +20,8 @@
 import java.util.List;
 import java.util.Map;
 
+import com.google.inject.spi.TypeConverterBinding;
+
 /**
  * Builds the graphs of objects that make up your application. The injector tracks the dependencies
  * for each type and uses bindings to inject them. This is the core of Guice, although you rarely
@@ -232,4 +234,12 @@
    * <p>This method is part of the Guice SPI and is intended for use by tools and extensions.
    */
   Map<Class<? extends Annotation>, Scope> getScopeBindings();
+
+  /**
+   * Returns a list containing all type converter bindings in the injector. The returned list
+   * is immutable.
+   *
+   * <p>This method is part of the Guice SPI and is intended for use by tools and extensions.
+   */
+  List<TypeConverterBinding> getTypeConverterBindings();
 }
diff -urwN guice-trunk/src/com/google/inject/internal/BindingProcessor.java guice-patches-2.1.1/src/com/google/inject/internal/BindingProcessor.java
--- guice-trunk/src/com/google/inject/internal/BindingProcessor.java	2010-02-12 06:07:07.298517000 +0800
+++ guice-patches-2.1.1/src/com/google/inject/internal/BindingProcessor.java	2010-02-16 15:11:49.212339000 +0800
@@ -219,8 +219,12 @@
   }
 
   private <T> void validateKey(Object source, Key<T> key) {
-    Annotations.checkForMisplacedScopeAnnotations(
-        key.getTypeLiteral().getRawType(), source, errors);
+// ------------------------------------------------------------------
+// MCCULLS: disable check, Nexus uses Scope annotations on interfaces
+// ------------------------------------------------------------------
+//  Annotations.checkForMisplacedScopeAnnotations(
+//      key.getTypeLiteral().getRawType(), source, errors);
+// ------------------------------------------------------------------
   }
 
   <T> UntargettedBindingImpl<T> invalidBinding(InjectorImpl injector, Key<T> key, Object source) {
diff -urwN guice-trunk/src/com/google/inject/internal/BytecodeGen.java guice-patches-2.1.1/src/com/google/inject/internal/BytecodeGen.java
--- guice-trunk/src/com/google/inject/internal/BytecodeGen.java	2009-06-07 01:51:27.912017000 +0800
+++ guice-patches-2.1.1/src/com/google/inject/internal/BytecodeGen.java	2010-02-19 00:48:17.748594000 +0800
@@ -16,7 +16,6 @@
 
 package com.google.inject.internal;
 
-import static com.google.inject.internal.Preconditions.checkNotNull;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Member;
 import java.lang.reflect.Method;
@@ -57,17 +56,22 @@
  */
 final class BytecodeGen {
 
-  private static final Logger logger = Logger.getLogger(BytecodeGen.class.getName());
+  static final Logger logger = Logger.getLogger(BytecodeGen.class.getName());
 
-  static final ClassLoader GUICE_CLASS_LOADER = BytecodeGen.class.getClassLoader();
+  static final ClassLoader GUICE_CLASS_LOADER = canonicalize(BytecodeGen.class.getClassLoader());
+
+  // initialization-on-demand...
+  private static class SystemBridgeHolder {
+    static final BridgeClassLoader SYSTEM_BRIDGE = new BridgeClassLoader();
+  }
 
   /** ie. "com.google.inject.internal" */
-  private static final String GUICE_INTERNAL_PACKAGE
+  static final String GUICE_INTERNAL_PACKAGE
       = BytecodeGen.class.getName().replaceFirst("\\.internal\\..*$", ".internal");
 
   /*if[AOP]*/
   /** either "net.sf.cglib", or "com.google.inject.internal.cglib" */
-  private static final String CGLIB_PACKAGE
+  static final String CGLIB_PACKAGE
       = net.sf.cglib.proxy.Enhancer.class.getName().replaceFirst("\\.cglib\\..*$", ".cglib");
 
   static final net.sf.cglib.core.NamingPolicy NAMING_POLICY
@@ -82,8 +86,8 @@
   end[NO_AOP]*/
 
   /** Use "-Dguice.custom.loader=false" to disable custom classloading. */
-  static final boolean HOOK_ENABLED
-      = "true".equals(System.getProperty("guice.custom.loader", "true"));
+  private static final boolean CUSTOM_LOADER_ENABLED
+      = Boolean.parseBoolean(System.getProperty("guice.custom.loader", "true"));
 
   /**
    * Weak cache of bridge class loaders that make the Guice implementation
@@ -103,26 +107,11 @@
   });
 
   /**
-   * For class loaders, {@code null}, is always an alias to the
-   * {@link ClassLoader#getSystemClassLoader() system class loader}. This method
-   * will not return null.
+   * Attempts to canonicalize null references to the system class loader.
+   * May return null if for some reason the system loader is unavailable.
    */
   private static ClassLoader canonicalize(ClassLoader classLoader) {
-    return classLoader != null
-        ? classLoader
-        : checkNotNull(getSystemClassLoaderOrNull(), "Couldn't get a ClassLoader");
-  }
-
-  /**
-   * Returns the system classloader, or {@code null} if we don't have
-   * permission.
-   */
-  private static ClassLoader getSystemClassLoaderOrNull() {
-    try {
-      return ClassLoader.getSystemClassLoader();
-    } catch (SecurityException e) {
-      return null;
-    }
+    return classLoader != null ? classLoader : SystemBridgeHolder.SYSTEM_BRIDGE.getParent();
   }
 
   /**
@@ -133,23 +122,30 @@
   }
 
   private static ClassLoader getClassLoader(Class<?> type, ClassLoader delegate) {
-    delegate = canonicalize(delegate);
 
-    // if the application is running in the System classloader, assume we can run there too
-    if (delegate == getSystemClassLoaderOrNull()) {
+    // simple case: do nothing!
+    if (!CUSTOM_LOADER_ENABLED) {
       return delegate;
     }
 
-    // Don't bother bridging existing bridge classloaders
-    if (delegate instanceof BridgeClassLoader) {
+    delegate = canonicalize(delegate);
+
+    // no need for a bridge if using same class loader, or it's already a bridge
+    if (delegate == GUICE_CLASS_LOADER || delegate instanceof BridgeClassLoader) {
       return delegate;
     }
 
-    if (HOOK_ENABLED && Visibility.forType(type) == Visibility.PUBLIC) {
+    // don't try bridging private types as it won't work
+    if (Visibility.forType(type) == Visibility.PUBLIC) {
+      if (delegate != SystemBridgeHolder.SYSTEM_BRIDGE.getParent()) {
+        // delegate guaranteed to be non-null here
       return CLASS_LOADER_CACHE.get(delegate);
     }
+      // delegate may or may not be null here
+      return SystemBridgeHolder.SYSTEM_BRIDGE;
+    }
 
-    return delegate;
+    return delegate; // last-resort: do nothing!
   }
 
   /*if[AOP]*/
@@ -193,6 +189,7 @@
      * target class. These generated classes may be loaded by our bridge classloader.
      */
     PUBLIC {
+      @Override
       public Visibility and(Visibility that) {
         return that;
       }
@@ -205,6 +202,7 @@
      * garbage collected.
      */
     SAME_PACKAGE {
+      @Override
       public Visibility and(Visibility that) {
         return this;
       }
@@ -242,26 +240,43 @@
    */
   private static class BridgeClassLoader extends ClassLoader {
 
-    public BridgeClassLoader(ClassLoader usersClassLoader) {
+    BridgeClassLoader() {
+      // use system loader as parent
+    }
+
+    BridgeClassLoader(ClassLoader usersClassLoader) {
       super(usersClassLoader);
     }
 
     @Override protected Class<?> loadClass(String name, boolean resolve)
         throws ClassNotFoundException {
 
-      // delegate internal requests to Guice class space
+      if (name.startsWith("sun.reflect")) {
+        // these reflection classes need to be loaded from the bootstrap class loader
+        return SystemBridgeHolder.SYSTEM_BRIDGE.loadClassFromParent(name, resolve);
+      }
+
       if (name.startsWith(GUICE_INTERNAL_PACKAGE) || name.startsWith(CGLIB_PACKAGE)) {
+        if (null == GUICE_CLASS_LOADER) {
+          // use special system bridge to load classes from the bootstrap class loader
+          return SystemBridgeHolder.SYSTEM_BRIDGE.loadClassFromParent(name, resolve);
+        }
         try {
           Class<?> clazz = GUICE_CLASS_LOADER.loadClass(name);
           if (resolve) {
             resolveClass(clazz);
           }
           return clazz;
-        } catch (Exception e) {
-          // fall back to classic delegation
+        } catch (Throwable e) {
+          // fall-back to classic delegation
         }
       }
 
+      return loadClassFromParent(name, resolve);
+    }
+
+    Class<?> loadClassFromParent(String name, boolean resolve)
+      throws ClassNotFoundException {
       return super.loadClass(name, resolve);
     }
   }
diff -urwN guice-trunk/src/com/google/inject/internal/DefaultConstructionProxyFactory.java guice-patches-2.1.1/src/com/google/inject/internal/DefaultConstructionProxyFactory.java
--- guice-trunk/src/com/google/inject/internal/DefaultConstructionProxyFactory.java	2009-06-07 01:51:27.912017000 +0800
+++ guice-patches-2.1.1/src/com/google/inject/internal/DefaultConstructionProxyFactory.java	2009-12-16 01:32:52.779554000 +0800
@@ -24,6 +24,8 @@
 import java.lang.reflect.Modifier;
 import java.util.List;
 
+import net.sf.cglib.core.CodeGenerationException;
+
 /**
  * Produces construction proxies that invoke the class constructor.
  *
@@ -47,6 +49,7 @@
     // Use FastConstructor if the constructor is public.
     if (Modifier.isPublic(constructor.getModifiers())) {
       /*if[AOP]*/
+      try {
       return new ConstructionProxy<T>() {
         Class<T> classToConstruct = constructor.getDeclaringClass();
         final net.sf.cglib.reflect.FastConstructor fastConstructor
@@ -68,6 +71,10 @@
           return ImmutableMap.of();
         }
       };
+      } catch (CodeGenerationException e) {
+        // FastConstructor failed: make accessible before reverting to JDK reflection
+        constructor.setAccessible(true);
+      }
       /*end[AOP]*/
     } else {
       constructor.setAccessible(true);
diff -urwN guice-trunk/src/com/google/inject/internal/Errors.java guice-patches-2.1.1/src/com/google/inject/internal/Errors.java
--- guice-trunk/src/com/google/inject/internal/Errors.java	2010-02-12 06:07:07.298517000 +0800
+++ guice-patches-2.1.1/src/com/google/inject/internal/Errors.java	2010-02-16 15:11:49.212339000 +0800
@@ -28,6 +28,7 @@
 import com.google.inject.spi.InjectionListener;
 import com.google.inject.spi.InjectionPoint;
 import com.google.inject.spi.Message;
+import com.google.inject.spi.TypeConverterBinding;
 import com.google.inject.spi.TypeListenerBinding;
 import java.io.PrintWriter;
 import java.io.Serializable;
@@ -46,7 +47,7 @@
 
 /**
  * A collection of error messages. If this type is passed as a method parameter, the method is
- * considered to have executed succesfully only if new errors were not added to this collection.
+ * considered to have executed successfully only if new errors were not added to this collection.
  *
  * <p>Errors can be chained to provide additional context. To add context, call {@link #withSource}
  * to create a new Errors instance that contains additional context. All messages added to the
@@ -130,30 +131,30 @@
   }
 
   public Errors converterReturnedNull(String stringValue, Object source,
-      TypeLiteral<?> type, MatcherAndConverter matchingConverter) {
+      TypeLiteral<?> type, TypeConverterBinding typeConverterBinding) {
     return addMessage("Received null converting '%s' (bound at %s) to %s%n"
         + " using %s.",
-        stringValue, convert(source), type, matchingConverter);
+        stringValue, convert(source), type, typeConverterBinding);
   }
 
   public Errors conversionTypeError(String stringValue, Object source, TypeLiteral<?> type,
-      MatcherAndConverter matchingConverter, Object converted) {
+      TypeConverterBinding typeConverterBinding, Object converted) {
     return addMessage("Type mismatch converting '%s' (bound at %s) to %s%n"
         + " using %s.%n"
         + " Converter returned %s.",
-        stringValue, convert(source), type, matchingConverter, converted);
+        stringValue, convert(source), type, typeConverterBinding, converted);
   }
 
   public Errors conversionError(String stringValue, Object source,
-      TypeLiteral<?> type, MatcherAndConverter matchingConverter, RuntimeException cause) {
+      TypeLiteral<?> type, TypeConverterBinding typeConverterBinding, RuntimeException cause) {
     return errorInUserCode(cause, "Error converting '%s' (bound at %s) to %s%n"
         + " using %s.%n"
         + " Reason: %s",
-        stringValue, convert(source), type, matchingConverter, cause);
+        stringValue, convert(source), type, typeConverterBinding, cause);
   }
 
   public Errors ambiguousTypeConversion(String stringValue, Object source, TypeLiteral<?> type,
-      MatcherAndConverter a, MatcherAndConverter b) {
+      TypeConverterBinding a, TypeConverterBinding b) {
     return addMessage("Multiple converters can convert '%s' (bound at %s) to %s:%n"
         + " %s and%n"
         + " %s.%n"
@@ -573,7 +574,7 @@
     }
 
     boolean appliesTo(Object o) {
-      return type.isAssignableFrom(o.getClass());
+      return o != null && type.isAssignableFrom(o.getClass());
     }
 
     String convert(Object o) {
diff -urwN guice-trunk/src/com/google/inject/internal/InheritingState.java guice-patches-2.1.1/src/com/google/inject/internal/InheritingState.java
--- guice-trunk/src/com/google/inject/internal/InheritingState.java	2009-07-24 08:48:12.842057000 +0800
+++ guice-patches-2.1.1/src/com/google/inject/internal/InheritingState.java	2009-12-16 01:32:52.779554000 +0800
@@ -21,6 +21,8 @@
 import com.google.inject.Scope;
 import com.google.inject.TypeLiteral;
 import static com.google.inject.internal.Preconditions.checkNotNull;
+
+import com.google.inject.spi.TypeConverterBinding;
 import com.google.inject.spi.TypeListenerBinding;
 import java.lang.annotation.Annotation;
 import java.util.ArrayList;
@@ -40,7 +42,7 @@
   private final Map<Key<?>, Binding<?>> explicitBindings
       = Collections.unmodifiableMap(explicitBindingsMutable);
   private final Map<Class<? extends Annotation>, Scope> scopes = Maps.newHashMap();
-  private final List<MatcherAndConverter> converters = Lists.newArrayList();
+  private final List<TypeConverterBinding> converters = Lists.newArrayList();
   /*if[AOP]*/
   private final List<MethodAspect> methodAspects = Lists.newArrayList();
   /*end[AOP]*/
@@ -80,19 +82,19 @@
     scopes.put(annotationType, scope);
   }
 
-  public Iterable<MatcherAndConverter> getConvertersThisLevel() {
+  public List<TypeConverterBinding> getConvertersThisLevel() {
     return converters;
   }
 
-  public void addConverter(MatcherAndConverter matcherAndConverter) {
-    converters.add(matcherAndConverter);
+  public void addConverter(TypeConverterBinding typeConverterBinding) {
+    converters.add(typeConverterBinding);
   }
 
-  public MatcherAndConverter getConverter(
+  public TypeConverterBinding getConverter(
       String stringValue, TypeLiteral<?> type, Errors errors, Object source) {
-    MatcherAndConverter matchingConverter = null;
+    TypeConverterBinding matchingConverter = null;
     for (State s = this; s != State.NONE; s = s.parent()) {
-      for (MatcherAndConverter converter : s.getConvertersThisLevel()) {
+      for (TypeConverterBinding converter : s.getConvertersThisLevel()) {
         if (converter.getTypeMatcher().matches(type)) {
           if (matchingConverter != null) {
             errors.ambiguousTypeConversion(stringValue, source, type, matchingConverter, converter);
diff -urwN guice-trunk/src/com/google/inject/internal/InjectorImpl.java guice-patches-2.1.1/src/com/google/inject/internal/InjectorImpl.java
--- guice-trunk/src/com/google/inject/internal/InjectorImpl.java	2010-02-14 00:16:44.563660000 +0800
+++ guice-patches-2.1.1/src/com/google/inject/internal/InjectorImpl.java	2010-02-17 22:30:57.321460000 +0800
@@ -37,6 +37,7 @@
 import com.google.inject.spi.HasDependencies;
 import com.google.inject.spi.InjectionPoint;
 import com.google.inject.spi.ProviderBinding;
+import com.google.inject.spi.TypeConverterBinding;
 import com.google.inject.util.Providers;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.GenericArrayType;
@@ -305,9 +306,9 @@
 
     // Find a matching type converter.
     TypeLiteral<T> type = key.getTypeLiteral();
-    MatcherAndConverter matchingConverter = state.getConverter(stringValue, type, errors, source);
+    TypeConverterBinding typeConverterBinding = state.getConverter(stringValue, type, errors, source);
 
-    if (matchingConverter == null) {
+    if (typeConverterBinding == null) {
       // No converter can handle the given type.
       return null;
     }
@@ -315,23 +316,24 @@
     // Try to convert the string. A failed conversion results in an error.
     try {
       @SuppressWarnings("unchecked") // This cast is safe because we double check below.
-      T converted = (T) matchingConverter.getTypeConverter().convert(stringValue, type);
+      T converted = (T) typeConverterBinding.getTypeConverter().convert(stringValue, type);
 
       if (converted == null) {
-        throw errors.converterReturnedNull(stringValue, source, type, matchingConverter)
+        throw errors.converterReturnedNull(stringValue, source, type, typeConverterBinding)
             .toException();
       }
 
       if (!type.getRawType().isInstance(converted)) {
-        throw errors.conversionTypeError(stringValue, source, type, matchingConverter, converted)
+        throw errors.conversionTypeError(stringValue, source, type, typeConverterBinding, converted)
             .toException();
       }
 
-      return new ConvertedConstantBindingImpl<T>(this, key, converted, stringBinding);
+      return new ConvertedConstantBindingImpl<T>(this, key, converted, stringBinding,
+            typeConverterBinding);
     } catch (ErrorsException e) {
       throw e;
     } catch (RuntimeException e) {
-      throw errors.conversionError(stringValue, source, type, matchingConverter, e)
+      throw errors.conversionError(stringValue, source, type, typeConverterBinding, e)
           .toException();
     }
   }
@@ -341,14 +343,17 @@
     final T value;
     final Provider<T> provider;
     final Binding<String> originalBinding;
+    final TypeConverterBinding typeConverterBinding;
 
     ConvertedConstantBindingImpl(
-        InjectorImpl injector, Key<T> key, T value, Binding<String> originalBinding) {
+        InjectorImpl injector, Key<T> key, T value, Binding<String> originalBinding,
+        TypeConverterBinding typeConverterBinding) {
       super(injector, key, originalBinding.getSource(),
           new ConstantFactory<T>(Initializables.of(value)), Scoping.UNSCOPED);
       this.value = value;
       provider = Providers.of(value);
       this.originalBinding = originalBinding;
+      this.typeConverterBinding = typeConverterBinding;
     }
 
     @Override public Provider<T> getProvider() {
@@ -363,6 +368,10 @@
       return value;
     }
 
+    public TypeConverterBinding getTypeConverterBinding() {
+      return typeConverterBinding;
+    }
+
     public Key<String> getSourceKey() {
       return originalBinding.getKey();
     }
@@ -576,7 +585,7 @@
   private <T> BindingImpl<T> createJustInTimeBindingRecursive(Key<T> key, Errors errors)
       throws ErrorsException {
     // ask the parent to create the JIT binding
-    if (parent != null && !parent.options.jitDisabled) {
+    if (false && parent != null && !parent.options.jitDisabled) { // MCCULLS: disable parent JIT bindings
       try {
         return parent.createJustInTimeBindingRecursive(key, new Errors());
       } catch (ErrorsException ignored) {
@@ -678,7 +687,11 @@
   }
 
   public Map<Class<? extends Annotation>, Scope> getScopeBindings() {
-    return state.getScopes();
+    return Collections.unmodifiableMap(state.getScopes());
+  }
+
+  public List<TypeConverterBinding> getTypeConverterBindings() {
+    return Collections.unmodifiableList(state.getConvertersThisLevel());
   }
 
   private static class BindingsMultimap {
diff -urwN guice-trunk/src/com/google/inject/internal/InternalContext.java guice-patches-2.1.1/src/com/google/inject/internal/InternalContext.java
--- guice-trunk/src/com/google/inject/internal/InternalContext.java	2009-06-23 08:29:43.635093000 +0800
+++ guice-patches-2.1.1/src/com/google/inject/internal/InternalContext.java	2009-12-16 01:32:52.779554000 +0800
@@ -46,7 +46,7 @@
   }
 
   public Dependency setDependency(Dependency dependency) {
-    Dependency previous = dependency;
+    Dependency previous = this.dependency;
     this.dependency = dependency;
     return previous;
   }
diff -urwN guice-trunk/src/com/google/inject/internal/InternalInjectorCreator.java guice-patches-2.1.1/src/com/google/inject/internal/InternalInjectorCreator.java
--- guice-trunk/src/com/google/inject/internal/InternalInjectorCreator.java	2010-02-14 00:16:44.563660000 +0800
+++ guice-patches-2.1.1/src/com/google/inject/internal/InternalInjectorCreator.java	2010-02-16 15:11:49.212339000 +0800
@@ -26,6 +26,7 @@
 import com.google.inject.TypeLiteral;
 import com.google.inject.Scope;
 import com.google.inject.spi.Dependency;
+import com.google.inject.spi.TypeConverterBinding;
 
 import java.util.Collection;
 import java.util.List;
@@ -280,6 +281,9 @@
     public Map<Class<? extends Annotation>, Scope> getScopeBindings() {
       return delegateInjector.getScopeBindings();
     }
+    public List<TypeConverterBinding> getTypeConverterBindings() {
+      return delegateInjector.getTypeConverterBindings();
+    }
     public <T> Provider<T> getProvider(Key<T> key) {
       throw new UnsupportedOperationException(
         "Injector.getProvider(Key<T>) is not supported in Stage.TOOL");
diff -urwN guice-trunk/src/com/google/inject/internal/MatcherAndConverter.java guice-patches-2.1.1/src/com/google/inject/internal/MatcherAndConverter.java
--- guice-trunk/src/com/google/inject/internal/MatcherAndConverter.java	2009-06-07 01:51:27.912017000 +0800
+++ guice-patches-2.1.1/src/com/google/inject/internal/MatcherAndConverter.java	2009-12-16 01:32:52.779554000 +0800
@@ -1,56 +0,0 @@
-/*
- * Copyright (C) 2007 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.inject.internal;
-
-import com.google.inject.TypeLiteral;
-import static com.google.inject.internal.Preconditions.checkNotNull;
-import com.google.inject.matcher.Matcher;
-import com.google.inject.spi.TypeConverter;
-
-/**
- * @author crazybob@google.com (Bob Lee)
- */
-final class MatcherAndConverter {
-
-  private final Matcher<? super TypeLiteral<?>> typeMatcher;
-  private final TypeConverter typeConverter;
-  private final Object source;
-
-  public MatcherAndConverter(Matcher<? super TypeLiteral<?>> typeMatcher,
-      TypeConverter typeConverter, Object source) {
-    this.typeMatcher = checkNotNull(typeMatcher, "type matcher");
-    this.typeConverter = checkNotNull(typeConverter, "converter");
-    this.source = source;
-  }
-
-  public TypeConverter getTypeConverter() {
-    return typeConverter;
-  }
-
-  public Matcher<? super TypeLiteral<?>> getTypeMatcher() {
-    return typeMatcher;
-  }
-
-  public Object getSource() {
-    return source;
-  }
-
-  @Override public String toString() {
-    return typeConverter + " which matches " + typeMatcher
-        + " (bound at " + source + ")";
-  }
-}
diff -urwN guice-trunk/src/com/google/inject/internal/ProxyFactory.java guice-patches-2.1.1/src/com/google/inject/internal/ProxyFactory.java
--- guice-trunk/src/com/google/inject/internal/ProxyFactory.java	2009-06-07 01:51:27.912017000 +0800
+++ guice-patches-2.1.1/src/com/google/inject/internal/ProxyFactory.java	2009-12-16 01:32:52.779554000 +0800
@@ -17,6 +17,8 @@
 package com.google.inject.internal;
 
 import static com.google.inject.internal.BytecodeGen.newFastClass;
+
+import com.google.inject.ProvisionException;
 import com.google.inject.spi.InjectionPoint;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
@@ -153,10 +155,14 @@
 
     // Create the proxied class. We're careful to ensure that all enhancer state is not-specific
     // to this injector. Otherwise, the proxies for each injector will waste PermGen memory
+    try {
     Enhancer enhancer = BytecodeGen.newEnhancer(declaringClass, visibility);
     enhancer.setCallbackFilter(new IndicesCallbackFilter(declaringClass, methods));
     enhancer.setCallbackTypes(callbackTypes);
     return new ProxyConstructor<T>(enhancer, injectionPoint, callbacks, interceptors);
+    } catch (Throwable e) {
+      throw new ProvisionException("Unable to method intercept: " + declaringClass, e);
+  }
   }
 
   private static class MethodInterceptorsPair {
diff -urwN guice-trunk/src/com/google/inject/internal/SingleMethodInjector.java guice-patches-2.1.1/src/com/google/inject/internal/SingleMethodInjector.java
--- guice-trunk/src/com/google/inject/internal/SingleMethodInjector.java	2009-06-07 01:51:27.912017000 +0800
+++ guice-patches-2.1.1/src/com/google/inject/internal/SingleMethodInjector.java	2009-12-16 01:32:52.779554000 +0800
@@ -23,6 +23,8 @@
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 
+import net.sf.cglib.core.CodeGenerationException;
+
 /**
  * Invokes an injectable method.
  */
@@ -45,6 +47,7 @@
     int modifiers = method.getModifiers();
     if (!Modifier.isPrivate(modifiers) && !Modifier.isProtected(modifiers)) {
       /*if[AOP]*/
+      try {
       final net.sf.cglib.reflect.FastMethod fastMethod
           = BytecodeGen.newFastClass(method.getDeclaringClass(), Visibility.forMember(method))
               .getMethod(method);
@@ -55,6 +58,10 @@
           return fastMethod.invoke(target, parameters);
         }
       };
+      } catch (CodeGenerationException e) {
+        // FastMethod failed: make accessible before reverting to JDK reflection
+        method.setAccessible(true);
+      }
       /*end[AOP]*/
     }
 
diff -urwN guice-trunk/src/com/google/inject/internal/State.java guice-patches-2.1.1/src/com/google/inject/internal/State.java
--- guice-trunk/src/com/google/inject/internal/State.java	2009-07-24 08:48:12.842057000 +0800
+++ guice-patches-2.1.1/src/com/google/inject/internal/State.java	2009-12-16 01:32:52.779554000 +0800
@@ -20,6 +20,7 @@
 import com.google.inject.Key;
 import com.google.inject.Scope;
 import com.google.inject.TypeLiteral;
+import com.google.inject.spi.TypeConverterBinding;
 import com.google.inject.spi.TypeListenerBinding;
 import java.lang.annotation.Annotation;
 import java.util.List;
@@ -58,17 +59,17 @@
       throw new UnsupportedOperationException();
     }
 
-    public void addConverter(MatcherAndConverter matcherAndConverter) {
+    public void addConverter(TypeConverterBinding typeConverterBinding) {
       throw new UnsupportedOperationException();
     }
 
-    public MatcherAndConverter getConverter(String stringValue, TypeLiteral<?> type, Errors errors,
+    public TypeConverterBinding getConverter(String stringValue, TypeLiteral<?> type, Errors errors,
         Object source) {
       throw new UnsupportedOperationException();
     }
 
-    public Iterable<MatcherAndConverter> getConvertersThisLevel() {
-      return ImmutableSet.of();
+    public List<TypeConverterBinding> getConvertersThisLevel() {
+      return ImmutableList.of();
     }
 
     /*if[AOP]*/
@@ -120,14 +121,14 @@
 
   void putAnnotation(Class<? extends Annotation> annotationType, Scope scope);
 
-  void addConverter(MatcherAndConverter matcherAndConverter);
+  void addConverter(TypeConverterBinding typeConverterBinding);
 
   /** Returns the matching converter for {@code type}, or null if none match. */
-  MatcherAndConverter getConverter(
+  TypeConverterBinding getConverter(
       String stringValue, TypeLiteral<?> type, Errors errors, Object source);
 
   /** Returns all converters at this level only. */
-  Iterable<MatcherAndConverter> getConvertersThisLevel();
+  List<TypeConverterBinding> getConvertersThisLevel();
 
   /*if[AOP]*/
   void addMethodAspect(MethodAspect methodAspect);
diff -urwN guice-trunk/src/com/google/inject/internal/TypeConverterBindingImpl.java guice-patches-2.1.1/src/com/google/inject/internal/TypeConverterBindingImpl.java
--- guice-trunk/src/com/google/inject/internal/TypeConverterBindingImpl.java	1970-01-01 08:00:00.000000000 +0800
+++ guice-patches-2.1.1/src/com/google/inject/internal/TypeConverterBindingImpl.java	2009-12-16 01:32:52.779554000 +0800
@@ -0,0 +1,66 @@
+/**
+ * Copyright (C) 2008 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.inject.internal;
+
+import com.google.inject.TypeLiteral;
+import com.google.inject.Binder;
+import static com.google.inject.internal.Preconditions.checkNotNull;
+import com.google.inject.matcher.Matcher;
+import com.google.inject.spi.ElementVisitor;
+import com.google.inject.spi.TypeConverter;
+import com.google.inject.spi.TypeConverterBinding;
+
+/**
+ * @author jessewilson@google.com (Jesse Wilson)
+ */
+public final class TypeConverterBindingImpl implements TypeConverterBinding {
+  private final Object source;
+  private final Matcher<? super TypeLiteral<?>> typeMatcher;
+  private final TypeConverter typeConverter;
+
+  public TypeConverterBindingImpl(Object source, Matcher<? super TypeLiteral<?>> typeMatcher,
+      TypeConverter typeConverter) {
+    this.source = checkNotNull(source, "source");
+    this.typeMatcher = checkNotNull(typeMatcher, "typeMatcher");
+    this.typeConverter = checkNotNull(typeConverter, "typeConverter");
+  }
+
+  public Object getSource() {
+    return source;
+  }
+
+  public Matcher<? super TypeLiteral<?>> getTypeMatcher() {
+    return typeMatcher;
+  }
+
+  public TypeConverter getTypeConverter() {
+    return typeConverter;
+  }
+
+  public <T> T acceptVisitor(ElementVisitor<T> visitor) {
+    return visitor.visit(this);
+  }
+
+  public void applyTo(Binder binder) {
+    binder.withSource(getSource()).convertToTypes(typeMatcher, typeConverter);
+  }
+
+  @Override public String toString() {
+    return typeConverter + " which matches " + typeMatcher
+        + " (bound at " + source + ")";
+  }
+}
diff -urwN guice-trunk/src/com/google/inject/internal/TypeConverterBindingProcessor.java guice-patches-2.1.1/src/com/google/inject/internal/TypeConverterBindingProcessor.java
--- guice-trunk/src/com/google/inject/internal/TypeConverterBindingProcessor.java	2009-06-07 01:51:27.912017000 +0800
+++ guice-patches-2.1.1/src/com/google/inject/internal/TypeConverterBindingProcessor.java	2009-12-16 01:32:52.779554000 +0800
@@ -159,12 +159,12 @@
   private void internalConvertToTypes(Matcher<? super TypeLiteral<?>> typeMatcher,
       TypeConverter converter) {
     injector.state.addConverter(
-        new MatcherAndConverter(typeMatcher, converter, SourceProvider.UNKNOWN_SOURCE));
+        new TypeConverterBindingImpl(SourceProvider.UNKNOWN_SOURCE, typeMatcher, converter));
   }
 
   @Override public Boolean visit(TypeConverterBinding command) {
-    injector.state.addConverter(new MatcherAndConverter(
-        command.getTypeMatcher(), command.getTypeConverter(), command.getSource()));
+    injector.state.addConverter(new TypeConverterBindingImpl(
+        command.getSource(), command.getTypeMatcher(), command.getTypeConverter()));
     return true;
   }
 }
diff -urwN guice-trunk/src/com/google/inject/spi/ConvertedConstantBinding.java guice-patches-2.1.1/src/com/google/inject/spi/ConvertedConstantBinding.java
--- guice-trunk/src/com/google/inject/spi/ConvertedConstantBinding.java	2008-12-27 10:57:04.090268000 +0800
+++ guice-patches-2.1.1/src/com/google/inject/spi/ConvertedConstantBinding.java	2009-12-16 01:32:52.779554000 +0800
@@ -35,6 +35,11 @@
   T getValue();
 
   /**
+   * Returns the type converter binding used to convert the constant.
+   */
+  TypeConverterBinding getTypeConverterBinding();
+
+  /**
    * Returns the key for the source binding. That binding can e retrieved from an injector using
    * {@link com.google.inject.Injector#getBinding(Key) Injector.getBinding(key)}.
    */
diff -urwN guice-trunk/src/com/google/inject/spi/Elements.java guice-patches-2.1.1/src/com/google/inject/spi/Elements.java
--- guice-trunk/src/com/google/inject/spi/Elements.java	2009-06-07 01:51:27.912017000 +0800
+++ guice-patches-2.1.1/src/com/google/inject/spi/Elements.java	2009-12-16 01:32:52.779554000 +0800
@@ -37,6 +37,8 @@
 import com.google.inject.internal.Errors;
 import com.google.inject.internal.ImmutableList;
 import com.google.inject.internal.Lists;
+import com.google.inject.internal.TypeConverterBindingImpl;
+
 import static com.google.inject.internal.Preconditions.checkArgument;
 import com.google.inject.internal.PrivateElementsImpl;
 import com.google.inject.internal.ProviderMethodsModule;
@@ -278,7 +280,7 @@
 
     public void convertToTypes(Matcher<? super TypeLiteral<?>> typeMatcher,
         TypeConverter converter) {
-      elements.add(new TypeConverterBinding(getSource(), typeMatcher, converter));
+      elements.add(new TypeConverterBindingImpl(getSource(), typeMatcher, converter));
     }
 
     public RecordingBinder withSource(final Object source) {
diff -urwN guice-trunk/src/com/google/inject/spi/TypeConverterBinding.java guice-patches-2.1.1/src/com/google/inject/spi/TypeConverterBinding.java
--- guice-trunk/src/com/google/inject/spi/TypeConverterBinding.java	2009-03-18 13:34:39.988564000 +0800
+++ guice-patches-2.1.1/src/com/google/inject/spi/TypeConverterBinding.java	2009-12-16 01:32:52.779554000 +0800
@@ -18,7 +18,6 @@
 
 import com.google.inject.TypeLiteral;
 import com.google.inject.Binder;
-import static com.google.inject.internal.Preconditions.checkNotNull;
 import com.google.inject.matcher.Matcher;
 
 /**
@@ -31,35 +30,15 @@
  * @author jessewilson@google.com (Jesse Wilson)
  * @since 2.0
  */
-public final class TypeConverterBinding implements Element {
-  private final Object source;
-  private final Matcher<? super TypeLiteral<?>> typeMatcher;
-  private final TypeConverter typeConverter;
-
-  TypeConverterBinding(Object source, Matcher<? super TypeLiteral<?>> typeMatcher,
-      TypeConverter typeConverter) {
-    this.source = checkNotNull(source, "source");
-    this.typeMatcher = checkNotNull(typeMatcher, "typeMatcher");
-    this.typeConverter = checkNotNull(typeConverter, "typeConverter");
-  }
+public interface TypeConverterBinding extends Element {
 
-  public Object getSource() {
-    return source;
-  }
+  Object getSource();
 
-  public Matcher<? super TypeLiteral<?>> getTypeMatcher() {
-    return typeMatcher;
-  }
+  Matcher<? super TypeLiteral<?>> getTypeMatcher();
 
-  public TypeConverter getTypeConverter() {
-    return typeConverter;
-  }
+  TypeConverter getTypeConverter();
 
-  public <T> T acceptVisitor(ElementVisitor<T> visitor) {
-    return visitor.visit(this);
-  }
+  <T> T acceptVisitor(ElementVisitor<T> visitor);
 
-  public void applyTo(Binder binder) {
-    binder.withSource(getSource()).convertToTypes(typeMatcher, typeConverter);
-  }
+  void applyTo(Binder binder);
 }
