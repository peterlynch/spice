diff -u -r -x pom.xml -x .svn -x .project -x .settings /home/stuart/Code/guice-vanilla/build.properties ./build.properties
--- /home/stuart/Code/guice-vanilla/build.properties	2010-02-16 14:31:43.678978300 +0800
+++ ./build.properties	2010-02-16 13:46:44.964978000 +0800
@@ -10,7 +10,7 @@
 multibindings.src.dir=extensions/multibindings/src
 privatemodules.src.dir=extensions/privatemodules/src
 lifecycle.src.dir=lifecycle/src
-build.dir=build
+build.dir=target
 javadoc.packagenames=com.google.inject,com.google.inject.spi,\
   com.google.inject.matcher,\
   com.google.inject.servlet,\
@@ -26,4 +26,7 @@
   com.google.inject.util
 test.class=com.google.inject.AllTests
 module=com.google.inject
-exclude.imports: !net.sf.cglib.*,!org.objectweb.asm.*
+imports=!net.sf.cglib.*,!org.objectweb.asm.*
+
+Bundle-Vendor: Sonatype Inc.
+Bundle-SymbolicName: org.sonatype.spice.inject.guice-patches
diff -u -r -x pom.xml -x .svn -x .project -x .settings /home/stuart/Code/guice-vanilla/build.xml ./build.xml
--- /home/stuart/Code/guice-vanilla/build.xml	2010-02-16 14:31:44.236978300 +0800
+++ ./build.xml	2010-02-16 14:18:43.683978300 +0800
@@ -2,9 +2,6 @@
 
 <project name="guice" default="compile">
 
-  <property name="DynamicImport-Package" value="org.aopalliance.intercept"/>
-  <property name="exclude.imports" value="!com.google.common.*,!net.sf.*,!org.objectweb.*"/>
-
   <import file="common.xml"/>
 
   <path id="compile.classpath">
@@ -12,7 +9,6 @@
     <fileset dir="${lib.dir}/build" includes="*.jar"/>
   </path>
 
-
   <target name="jar" depends="jar.withdeps, manifest" description="Build jar.">
     <jar jarfile="${build.dir}/dist/guice-${version}.jar"
         manifest="${build.dir}/META-INF/MANIFEST.MF">
@@ -90,10 +86,15 @@
         <pathelement location="lib/build/easymock.jar"/>
         <pathelement location="lib/javax.inject.jar"/>
         <pathelement location="lib/build/javax.inject-tck.jar"/>
+        <pathelement location="lib/build/bnd-0.0.384.jar"/>
+        <pathelement location="lib/build/felix-2.0.2.jar"/>
       </classpath>
       <arg value="com.google.inject.AllTests"/>    
       <syspropertyset>
         <propertyref name="guice.custom.loader"/>
+        <propertyref name="version"/>
+        <propertyref name="build.dir"/>
+        <propertyref name="lib.dir"/>
       </syspropertyset>
     </java>
   </target>
@@ -108,6 +109,7 @@
          windowtitle="Guice ${version} API">
       <sourcepath>
         <pathelement location="${src.dir}"/>
+<!--
         <pathelement location="${servlet.src.dir}"/>
         <pathelement location="${spring.src.dir}"/>
         <pathelement location="${assistedinject.src.dir}"/>
@@ -116,14 +118,20 @@
         <pathelement location="${throwingproviders.src.dir}"/>
         <pathelement location="${multibindings.src.dir}"/>
         <pathelement location="${lifecycle.src.dir}"/>
+-->
       </sourcepath>
       <classpath refid="compile.classpath"/>
+<!--
       <classpath>
         <fileset dir="servlet/lib/build" includes="*.jar"/>
       </classpath>
+-->
+      <link href="http://atinject.googlecode.com/svn/tags/1/javadoc"/>
       <link href="http://aopalliance.sourceforge.net/doc"/>
       <link href="http://java.sun.com/javase/6/docs/api"/>
+<!--
       <link href="http://www.springframework.org/docs/api/"/>
+-->
     </javadoc>
     <!-- generate core javadocs, used only for its left-side nav -->
     <mkdir dir="${build.dir}/javadoc-core"/>
@@ -134,6 +142,7 @@
          windowtitle="Guice ${version} Core API"
          sourcepath="${src.dir}">
       <classpath refid="compile.classpath"/>
+      <link href="http://atinject.googlecode.com/svn/tags/1/javadoc"/>
       <link href="http://aopalliance.sourceforge.net/doc"/>
       <link href="http://java.sun.com/javase/6/docs/api"/>
     </javadoc>
diff -u -r -x pom.xml -x .svn -x .project -x .settings /home/stuart/Code/guice-vanilla/common.xml ./common.xml
--- /home/stuart/Code/guice-vanilla/common.xml	2010-02-16 14:31:42.758978300 +0800
+++ ./common.xml	2010-02-16 13:49:15.099978000 +0800
@@ -25,13 +25,14 @@
   <target name="manifest" description="Generate OSGi manifest." depends="compile">
     <dirname property="common.basedir" file="${ant.file.common}"/>
     <taskdef resource="aQute/bnd/ant/taskdef.properties"
-      classpath="${common.basedir}/lib/build/bnd-0.0.305.jar"/>
+      classpath="${common.basedir}/lib/build/bnd-0.0.384.jar"/>
 
     <fail unless="module" message="Missing 'module' property (use the primary package name in this jar)"/>
+    <property name="imports" value=""/>
 
     <property name="Bundle-Name" value="${ant.project.name}"/>
     <property name="Bundle-SymbolicName" value="${module}"/>
-    <property name="Bundle-Version" value="${replace;${version};^[^0-9];${api.version}.$0}"/>
+    <property name="Bundle-Version" value="${replace;${version};^[^0-9];0.0.0.$0}"/>
 
     <property name="Bundle-Description" value="Guice is a lightweight dependency injection framework for Java 5 and above"/>
     <property name="Bundle-DocURL" value="http://code.google.com/p/google-guice/"/>
@@ -39,12 +40,18 @@
     <property name="Bundle-License" value="http://www.apache.org/licenses/LICENSE-2.0"/>
     <property name="Bundle-Vendor" value="Google Inc."/>
 
-    <property name="exclude.imports" value=""/>
-    <property name="api.range" value="&quot;[${api.version},${version;+;${api.version}})&quot;"/>
-    <property name="guice.imports" value="com.google.inject.*;version=${api.range}"/>
-    <property name="Import-Package" value="${exclude.imports},${guice.imports},*;resolution:=optional"/>
     <property name="Export-Package" value="!${module}.internal.*,${module}.*;version=${api.version}"/>
 
+    <condition property="Import-Package" value="!com.google.inject.*,*" else="!${module}.*,${imports},*">
+      <istrue value="${fragment}"/>
+    </condition>
+
+    <condition property="Fragment-Host" value="com.google.inject">
+      <istrue value="${fragment}"/>
+    </condition>
+
+    <property name="-nouses" value="true"/>
+
     <property name="-removeheaders" value="Bnd-LastModified,Ignore-Package,Include-Resource,Private-Package,Tool"/>
 
     <bndwrap jars="${build.dir}/classes" output="${build.dir}"/>
diff -u -r -x pom.xml -x .svn -x .project -x .settings /home/stuart/Code/guice-vanilla/src/com/google/inject/Injector.java ./src/com/google/inject/Injector.java
--- /home/stuart/Code/guice-vanilla/src/com/google/inject/Injector.java	2010-02-16 14:31:43.625978300 +0800
+++ ./src/com/google/inject/Injector.java	2010-02-16 13:34:54.176978000 +0800
@@ -20,6 +20,8 @@
 import java.util.List;
 import java.util.Map;
 
+import com.google.inject.spi.TypeConverterBinding;
+
 /**
  * Builds the graphs of objects that make up your application. The injector tracks the dependencies
  * for each type and uses bindings to inject them. This is the core of Guice, although you rarely
@@ -232,4 +234,12 @@
    * <p>This method is part of the Guice SPI and is intended for use by tools and extensions.
    */
   Map<Class<? extends Annotation>, Scope> getScopeBindings();
+
+  /**
+   * Returns a list containing all type converter bindings in the injector. The returned list
+   * is immutable.
+   *
+   * <p>This method is part of the Guice SPI and is intended for use by tools and extensions.
+   */
+  List<TypeConverterBinding> getTypeConverterBindings();
 }
diff -u -r -x pom.xml -x .svn -x .project -x .settings /home/stuart/Code/guice-vanilla/src/com/google/inject/internal/BindingProcessor.java ./src/com/google/inject/internal/BindingProcessor.java
--- /home/stuart/Code/guice-vanilla/src/com/google/inject/internal/BindingProcessor.java	2010-02-16 14:22:11.335978300 +0800
+++ ./src/com/google/inject/internal/BindingProcessor.java	2010-02-16 14:57:31.442978300 +0800
@@ -219,8 +219,12 @@
   }
 
   private <T> void validateKey(Object source, Key<T> key) {
-    Annotations.checkForMisplacedScopeAnnotations(
-        key.getTypeLiteral().getRawType(), source, errors);
+// ------------------------------------------------------------------
+// MCCULLS: disable check, Nexus uses Scope annotations on interfaces
+// ------------------------------------------------------------------
+//  Annotations.checkForMisplacedScopeAnnotations(
+//      key.getTypeLiteral().getRawType(), source, errors);
+// ------------------------------------------------------------------
   }
 
   <T> UntargettedBindingImpl<T> invalidBinding(InjectorImpl injector, Key<T> key, Object source) {
diff -u -r -x pom.xml -x .svn -x .project -x .settings /home/stuart/Code/guice-vanilla/src/com/google/inject/internal/BytecodeGen.java ./src/com/google/inject/internal/BytecodeGen.java
--- /home/stuart/Code/guice-vanilla/src/com/google/inject/internal/BytecodeGen.java	2010-02-16 14:31:43.313978300 +0800
+++ ./src/com/google/inject/internal/BytecodeGen.java	2010-02-16 13:33:58.979978000 +0800
@@ -16,7 +16,6 @@
 
 package com.google.inject.internal;
 
-import static com.google.inject.internal.Preconditions.checkNotNull;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Member;
 import java.lang.reflect.Method;
@@ -57,20 +56,45 @@
  */
 final class BytecodeGen {
 
-  private static final Logger logger = Logger.getLogger(BytecodeGen.class.getName());
+  static final Logger LOGGER = Logger.getLogger(BytecodeGen.class.getName());
 
-  static final ClassLoader GUICE_CLASS_LOADER = BytecodeGen.class.getClassLoader();
+  private static final class ClassSpace {
+    final ClassLoader classLoader;
+
+    ClassSpace(ClassLoader classLoader) {
+      this.classLoader = classLoader;
+    }
+
+    @Override public boolean equals( Object obj ) {
+      if (obj instanceof ClassSpace) {
+        return classLoader == ((ClassSpace)obj).classLoader;
+      }
+      return false;
+    }
+
+    @Override public int hashCode() {
+      return null == classLoader ? 0 : classLoader.hashCode();
+    }
+
+    @Override public String toString() {
+      return null == classLoader ? "SystemClassLoader" : classLoader.toString();
+    }
+  }
+
+  static final ClassSpace SYSTEM_CLASS_SPACE = getSystemClassSpace();
+
+  static final ClassSpace GUICE_CLASS_SPACE = getClassSpace(BytecodeGen.class.getClassLoader());
 
   /** ie. "com.google.inject.internal" */
-  private static final String GUICE_INTERNAL_PACKAGE
+  static final String GUICE_INTERNAL_PACKAGE
       = BytecodeGen.class.getName().replaceFirst("\\.internal\\..*$", ".internal");
 
   /*if[AOP]*/
   /** either "net.sf.cglib", or "com.google.inject.internal.cglib" */
-  private static final String CGLIB_PACKAGE
+  static final String CGLIB_PACKAGE
       = net.sf.cglib.proxy.Enhancer.class.getName().replaceFirst("\\.cglib\\..*$", ".cglib");
 
-  static final net.sf.cglib.core.NamingPolicy NAMING_POLICY
+  private static final net.sf.cglib.core.NamingPolicy NAMING_POLICY
       = new net.sf.cglib.core.DefaultNamingPolicy() {
     @Override protected String getTag() {
       return "ByGuice";
@@ -82,47 +106,41 @@
   end[NO_AOP]*/
 
   /** Use "-Dguice.custom.loader=false" to disable custom classloading. */
-  static final boolean HOOK_ENABLED
-      = "true".equals(System.getProperty("guice.custom.loader", "true"));
+  private static final boolean CUSTOM_LOADER_ENABLED
+      = "true".equalsIgnoreCase(System.getProperty("guice.custom.loader", "true"));
 
   /**
    * Weak cache of bridge class loaders that make the Guice implementation
    * classes visible to various code-generated proxies of client classes.
    */
-  private static final Map<ClassLoader, ClassLoader> CLASS_LOADER_CACHE
+  private static final Map<ClassSpace, ClassLoader> BRIDGE_CLASS_LOADER_CACHE
       = new MapMaker().weakKeys().weakValues().makeComputingMap(
-          new Function<ClassLoader, ClassLoader>() {
-    public ClassLoader apply(final @Nullable ClassLoader typeClassLoader) {
-      logger.fine("Creating a bridge ClassLoader for " + typeClassLoader);
+          new Function<ClassSpace, ClassLoader>() {
+    public ClassLoader apply(final ClassSpace classSpace) {
+      LOGGER.fine("Creating a bridge ClassLoader for " + classSpace);
       return AccessController.doPrivileged(new PrivilegedAction<ClassLoader>() {
         public ClassLoader run() {
-          return new BridgeClassLoader(typeClassLoader);
+          return new BridgeClassLoader(classSpace.classLoader);
         }
       });
     }
   });
 
-  /**
-   * For class loaders, {@code null}, is always an alias to the
-   * {@link ClassLoader#getSystemClassLoader() system class loader}. This method
-   * will not return null.
-   */
-  private static ClassLoader canonicalize(ClassLoader classLoader) {
-    return classLoader != null
-        ? classLoader
-        : checkNotNull(getSystemClassLoaderOrNull(), "Couldn't get a ClassLoader");
-  }
-
-  /**
-   * Returns the system classloader, or {@code null} if we don't have
-   * permission.
-   */
-  private static ClassLoader getSystemClassLoaderOrNull() {
+  private static ClassSpace getSystemClassSpace() {
+    ClassLoader systemClassLoader = null;
     try {
+      systemClassLoader = AccessController.doPrivileged(
+          new PrivilegedAction<ClassLoader>() {
+        public ClassLoader run() {
       return ClassLoader.getSystemClassLoader();
-    } catch (SecurityException e) {
-      return null;
     }
+      });
+    } catch (SecurityException e) {/* ignore */}
+    return new ClassSpace(systemClassLoader);
+  }
+
+  private static ClassSpace getClassSpace(ClassLoader classLoader) {
+    return null == classLoader ? SYSTEM_CLASS_SPACE : new ClassSpace(classLoader);
   }
 
   /**
@@ -133,10 +151,8 @@
   }
 
   private static ClassLoader getClassLoader(Class<?> type, ClassLoader delegate) {
-    delegate = canonicalize(delegate);
 
-    // if the application is running in the System classloader, assume we can run there too
-    if (delegate == getSystemClassLoaderOrNull()) {
+    if (!CUSTOM_LOADER_ENABLED) {
       return delegate;
     }
 
@@ -145,8 +161,15 @@
       return delegate;
     }
 
-    if (HOOK_ENABLED && Visibility.forType(type) == Visibility.PUBLIC) {
-      return CLASS_LOADER_CACHE.get(delegate);
+    ClassSpace classSpace = getClassSpace(delegate);
+
+    // same class space, no bridging required
+    if (GUICE_CLASS_SPACE.equals(classSpace)) {
+      return delegate;
+    }
+
+    if (Visibility.forType(type) == Visibility.PUBLIC) {
+      return BRIDGE_CLASS_LOADER_CACHE.get(classSpace);
     }
 
     return delegate;
@@ -162,7 +185,7 @@
       generator.setClassLoader(getClassLoader(type));
     }
     generator.setNamingPolicy(NAMING_POLICY);
-    logger.fine("Loading " + type + " FastClass with " + generator.getClassLoader());
+    LOGGER.fine("Loading " + type + " FastClass with " + generator.getClassLoader());
     return generator.create();
   }
 
@@ -174,7 +197,7 @@
       enhancer.setClassLoader(getClassLoader(type));
     }
     enhancer.setNamingPolicy(NAMING_POLICY);
-    logger.fine("Loading " + type + " Enhancer with " + enhancer.getClassLoader());
+    LOGGER.fine("Loading " + type + " Enhancer with " + enhancer.getClassLoader());
     return enhancer;
   }
   /*end[AOP]*/
@@ -193,7 +216,7 @@
      * target class. These generated classes may be loaded by our bridge classloader.
      */
     PUBLIC {
-      public Visibility and(Visibility that) {
+      @Override public Visibility and(Visibility that) {
         return that;
       }
     },
@@ -205,7 +228,7 @@
      * garbage collected.
      */
     SAME_PACKAGE {
-      public Visibility and(Visibility that) {
+      @Override public Visibility and(Visibility that) {
         return this;
       }
     };
@@ -215,8 +238,8 @@
         return SAME_PACKAGE;
       }
 
-      Class[] parameterTypes = member instanceof Constructor
-          ? ((Constructor) member).getParameterTypes()
+      Class<?>[] parameterTypes = member instanceof Constructor<?>
+          ? ((Constructor<?>) member).getParameterTypes()
           : ((Method) member).getParameterTypes();
       for (Class<?> type : parameterTypes) {
         if (forType(type) == SAME_PACKAGE) {
@@ -240,19 +263,27 @@
    * Loader for Guice-generated classes. For referenced classes, this delegates to either either the
    * user's classloader (which is the parent of this classloader) or Guice's class loader.
    */
-  private static class BridgeClassLoader extends ClassLoader {
+  private static final class BridgeClassLoader extends ClassLoader {
 
-    public BridgeClassLoader(ClassLoader usersClassLoader) {
+    BridgeClassLoader(ClassLoader usersClassLoader) {
       super(usersClassLoader);
     }
 
     @Override protected Class<?> loadClass(String name, boolean resolve)
         throws ClassNotFoundException {
 
-      // delegate internal requests to Guice class space
+      ClassSpace classSpace = null;
+
+      // redirect requests for Guice internal classes and reflection helpers
       if (name.startsWith(GUICE_INTERNAL_PACKAGE) || name.startsWith(CGLIB_PACKAGE)) {
+        classSpace = GUICE_CLASS_SPACE;
+      } else if (name.startsWith("sun.reflect")) {
+        classSpace = SYSTEM_CLASS_SPACE;
+      }
+
+      if (classSpace != null) {
         try {
-          Class<?> clazz = GUICE_CLASS_LOADER.loadClass(name);
+          Class<?> clazz = classSpace.classLoader.loadClass(name);
           if (resolve) {
             resolveClass(clazz);
           }
diff -u -r -x pom.xml -x .svn -x .project -x .settings /home/stuart/Code/guice-vanilla/src/com/google/inject/internal/DefaultConstructionProxyFactory.java ./src/com/google/inject/internal/DefaultConstructionProxyFactory.java
--- /home/stuart/Code/guice-vanilla/src/com/google/inject/internal/DefaultConstructionProxyFactory.java	2010-02-16 14:31:43.067978300 +0800
+++ ./src/com/google/inject/internal/DefaultConstructionProxyFactory.java	2010-02-16 13:33:58.901978000 +0800
@@ -24,6 +24,8 @@
 import java.lang.reflect.Modifier;
 import java.util.List;
 
+import net.sf.cglib.core.CodeGenerationException;
+
 /**
  * Produces construction proxies that invoke the class constructor.
  *
@@ -47,6 +49,7 @@
     // Use FastConstructor if the constructor is public.
     if (Modifier.isPublic(constructor.getModifiers())) {
       /*if[AOP]*/
+      try {
       return new ConstructionProxy<T>() {
         Class<T> classToConstruct = constructor.getDeclaringClass();
         final net.sf.cglib.reflect.FastConstructor fastConstructor
@@ -68,6 +71,10 @@
           return ImmutableMap.of();
         }
       };
+      } catch (CodeGenerationException e) {
+        // FastConstructor failed: make accessible before reverting to JDK reflection
+        constructor.setAccessible(true);
+      }
       /*end[AOP]*/
     } else {
       constructor.setAccessible(true);
diff -u -r -x pom.xml -x .svn -x .project -x .settings /home/stuart/Code/guice-vanilla/src/com/google/inject/internal/Errors.java ./src/com/google/inject/internal/Errors.java
--- /home/stuart/Code/guice-vanilla/src/com/google/inject/internal/Errors.java	2010-02-16 14:31:42.998978300 +0800
+++ ./src/com/google/inject/internal/Errors.java	2010-02-16 14:59:02.525978300 +0800
@@ -28,6 +28,7 @@
 import com.google.inject.spi.InjectionListener;
 import com.google.inject.spi.InjectionPoint;
 import com.google.inject.spi.Message;
+import com.google.inject.spi.TypeConverterBinding;
 import com.google.inject.spi.TypeListenerBinding;
 import java.io.PrintWriter;
 import java.io.Serializable;
@@ -46,7 +47,7 @@
 
 /**
  * A collection of error messages. If this type is passed as a method parameter, the method is
- * considered to have executed succesfully only if new errors were not added to this collection.
+ * considered to have executed successfully only if new errors were not added to this collection.
  *
  * <p>Errors can be chained to provide additional context. To add context, call {@link #withSource}
  * to create a new Errors instance that contains additional context. All messages added to the
@@ -130,30 +131,30 @@
   }
 
   public Errors converterReturnedNull(String stringValue, Object source,
-      TypeLiteral<?> type, MatcherAndConverter matchingConverter) {
+      TypeLiteral<?> type, TypeConverterBinding typeConverterBinding) {
     return addMessage("Received null converting '%s' (bound at %s) to %s%n"
         + " using %s.",
-        stringValue, convert(source), type, matchingConverter);
+        stringValue, convert(source), type, typeConverterBinding);
   }
 
   public Errors conversionTypeError(String stringValue, Object source, TypeLiteral<?> type,
-      MatcherAndConverter matchingConverter, Object converted) {
+      TypeConverterBinding typeConverterBinding, Object converted) {
     return addMessage("Type mismatch converting '%s' (bound at %s) to %s%n"
         + " using %s.%n"
         + " Converter returned %s.",
-        stringValue, convert(source), type, matchingConverter, converted);
+        stringValue, convert(source), type, typeConverterBinding, converted);
   }
 
   public Errors conversionError(String stringValue, Object source,
-      TypeLiteral<?> type, MatcherAndConverter matchingConverter, RuntimeException cause) {
+      TypeLiteral<?> type, TypeConverterBinding typeConverterBinding, RuntimeException cause) {
     return errorInUserCode(cause, "Error converting '%s' (bound at %s) to %s%n"
         + " using %s.%n"
         + " Reason: %s",
-        stringValue, convert(source), type, matchingConverter, cause);
+        stringValue, convert(source), type, typeConverterBinding, cause);
   }
 
   public Errors ambiguousTypeConversion(String stringValue, Object source, TypeLiteral<?> type,
-      MatcherAndConverter a, MatcherAndConverter b) {
+      TypeConverterBinding a, TypeConverterBinding b) {
     return addMessage("Multiple converters can convert '%s' (bound at %s) to %s:%n"
         + " %s and%n"
         + " %s.%n"
@@ -573,7 +574,7 @@
     }
 
     boolean appliesTo(Object o) {
-      return type.isAssignableFrom(o.getClass());
+      return o != null && type.isAssignableFrom(o.getClass());
     }
 
     String convert(Object o) {
diff -u -r -x pom.xml -x .svn -x .project -x .settings /home/stuart/Code/guice-vanilla/src/com/google/inject/internal/InheritingState.java ./src/com/google/inject/internal/InheritingState.java
--- /home/stuart/Code/guice-vanilla/src/com/google/inject/internal/InheritingState.java	2010-02-16 14:31:43.378978300 +0800
+++ ./src/com/google/inject/internal/InheritingState.java	2010-02-16 13:34:54.108978000 +0800
@@ -21,6 +21,8 @@
 import com.google.inject.Scope;
 import com.google.inject.TypeLiteral;
 import static com.google.inject.internal.Preconditions.checkNotNull;
+
+import com.google.inject.spi.TypeConverterBinding;
 import com.google.inject.spi.TypeListenerBinding;
 import java.lang.annotation.Annotation;
 import java.util.ArrayList;
@@ -40,7 +42,7 @@
   private final Map<Key<?>, Binding<?>> explicitBindings
       = Collections.unmodifiableMap(explicitBindingsMutable);
   private final Map<Class<? extends Annotation>, Scope> scopes = Maps.newHashMap();
-  private final List<MatcherAndConverter> converters = Lists.newArrayList();
+  private final List<TypeConverterBinding> converters = Lists.newArrayList();
   /*if[AOP]*/
   private final List<MethodAspect> methodAspects = Lists.newArrayList();
   /*end[AOP]*/
@@ -80,19 +82,19 @@
     scopes.put(annotationType, scope);
   }
 
-  public Iterable<MatcherAndConverter> getConvertersThisLevel() {
+  public List<TypeConverterBinding> getConvertersThisLevel() {
     return converters;
   }
 
-  public void addConverter(MatcherAndConverter matcherAndConverter) {
-    converters.add(matcherAndConverter);
+  public void addConverter(TypeConverterBinding typeConverterBinding) {
+    converters.add(typeConverterBinding);
   }
 
-  public MatcherAndConverter getConverter(
+  public TypeConverterBinding getConverter(
       String stringValue, TypeLiteral<?> type, Errors errors, Object source) {
-    MatcherAndConverter matchingConverter = null;
+    TypeConverterBinding matchingConverter = null;
     for (State s = this; s != State.NONE; s = s.parent()) {
-      for (MatcherAndConverter converter : s.getConvertersThisLevel()) {
+      for (TypeConverterBinding converter : s.getConvertersThisLevel()) {
         if (converter.getTypeMatcher().matches(type)) {
           if (matchingConverter != null) {
             errors.ambiguousTypeConversion(stringValue, source, type, matchingConverter, converter);
diff -u -r -x pom.xml -x .svn -x .project -x .settings /home/stuart/Code/guice-vanilla/src/com/google/inject/internal/InjectorImpl.java ./src/com/google/inject/internal/InjectorImpl.java
--- /home/stuart/Code/guice-vanilla/src/com/google/inject/internal/InjectorImpl.java	2010-02-16 14:31:43.109978300 +0800
+++ ./src/com/google/inject/internal/InjectorImpl.java	2010-02-16 14:04:09.849978000 +0800
@@ -37,6 +37,7 @@
 import com.google.inject.spi.HasDependencies;
 import com.google.inject.spi.InjectionPoint;
 import com.google.inject.spi.ProviderBinding;
+import com.google.inject.spi.TypeConverterBinding;
 import com.google.inject.util.Providers;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.GenericArrayType;
@@ -305,9 +306,9 @@
 
     // Find a matching type converter.
     TypeLiteral<T> type = key.getTypeLiteral();
-    MatcherAndConverter matchingConverter = state.getConverter(stringValue, type, errors, source);
+    TypeConverterBinding typeConverterBinding = state.getConverter(stringValue, type, errors, source);
 
-    if (matchingConverter == null) {
+    if (typeConverterBinding == null) {
       // No converter can handle the given type.
       return null;
     }
@@ -315,23 +316,24 @@
     // Try to convert the string. A failed conversion results in an error.
     try {
       @SuppressWarnings("unchecked") // This cast is safe because we double check below.
-      T converted = (T) matchingConverter.getTypeConverter().convert(stringValue, type);
+      T converted = (T) typeConverterBinding.getTypeConverter().convert(stringValue, type);
 
       if (converted == null) {
-        throw errors.converterReturnedNull(stringValue, source, type, matchingConverter)
+        throw errors.converterReturnedNull(stringValue, source, type, typeConverterBinding)
             .toException();
       }
 
       if (!type.getRawType().isInstance(converted)) {
-        throw errors.conversionTypeError(stringValue, source, type, matchingConverter, converted)
+        throw errors.conversionTypeError(stringValue, source, type, typeConverterBinding, converted)
             .toException();
       }
 
-      return new ConvertedConstantBindingImpl<T>(this, key, converted, stringBinding);
+      return new ConvertedConstantBindingImpl<T>(this, key, converted, stringBinding,
+            typeConverterBinding);
     } catch (ErrorsException e) {
       throw e;
     } catch (RuntimeException e) {
-      throw errors.conversionError(stringValue, source, type, matchingConverter, e)
+      throw errors.conversionError(stringValue, source, type, typeConverterBinding, e)
           .toException();
     }
   }
@@ -341,14 +343,17 @@
     final T value;
     final Provider<T> provider;
     final Binding<String> originalBinding;
+    final TypeConverterBinding typeConverterBinding;
 
     ConvertedConstantBindingImpl(
-        InjectorImpl injector, Key<T> key, T value, Binding<String> originalBinding) {
+        InjectorImpl injector, Key<T> key, T value, Binding<String> originalBinding,
+        TypeConverterBinding typeConverterBinding) {
       super(injector, key, originalBinding.getSource(),
           new ConstantFactory<T>(Initializables.of(value)), Scoping.UNSCOPED);
       this.value = value;
       provider = Providers.of(value);
       this.originalBinding = originalBinding;
+      this.typeConverterBinding = typeConverterBinding;
     }
 
     @Override public Provider<T> getProvider() {
@@ -363,6 +368,10 @@
       return value;
     }
 
+    public TypeConverterBinding getTypeConverterBinding() {
+      return typeConverterBinding;
+    }
+
     public Key<String> getSourceKey() {
       return originalBinding.getKey();
     }
@@ -678,7 +687,11 @@
   }
 
   public Map<Class<? extends Annotation>, Scope> getScopeBindings() {
-    return state.getScopes();
+    return Collections.unmodifiableMap(state.getScopes());
+  }
+
+  public List<TypeConverterBinding> getTypeConverterBindings() {
+    return Collections.unmodifiableList(state.getConvertersThisLevel());
   }
 
   private static class BindingsMultimap {
diff -u -r -x pom.xml -x .svn -x .project -x .settings /home/stuart/Code/guice-vanilla/src/com/google/inject/internal/InternalContext.java ./src/com/google/inject/internal/InternalContext.java
--- /home/stuart/Code/guice-vanilla/src/com/google/inject/internal/InternalContext.java	2010-02-16 14:31:43.517978300 +0800
+++ ./src/com/google/inject/internal/InternalContext.java	2010-02-16 13:39:50.520978000 +0800
@@ -46,7 +46,7 @@
   }
 
   public Dependency setDependency(Dependency dependency) {
-    Dependency previous = dependency;
+    Dependency previous = this.dependency;
     this.dependency = dependency;
     return previous;
   }
diff -u -r -x pom.xml -x .svn -x .project -x .settings /home/stuart/Code/guice-vanilla/src/com/google/inject/internal/InternalInjectorCreator.java ./src/com/google/inject/internal/InternalInjectorCreator.java
--- /home/stuart/Code/guice-vanilla/src/com/google/inject/internal/InternalInjectorCreator.java	2010-02-16 14:31:43.569978300 +0800
+++ ./src/com/google/inject/internal/InternalInjectorCreator.java	2010-02-16 14:12:47.619978000 +0800
@@ -26,6 +26,7 @@
 import com.google.inject.TypeLiteral;
 import com.google.inject.Scope;
 import com.google.inject.spi.Dependency;
+import com.google.inject.spi.TypeConverterBinding;
 
 import java.util.Collection;
 import java.util.List;
@@ -280,6 +281,9 @@
     public Map<Class<? extends Annotation>, Scope> getScopeBindings() {
       return delegateInjector.getScopeBindings();
     }
+    public List<TypeConverterBinding> getTypeConverterBindings() {
+      return delegateInjector.getTypeConverterBindings();
+    }
     public <T> Provider<T> getProvider(Key<T> key) {
       throw new UnsupportedOperationException(
         "Injector.getProvider(Key<T>) is not supported in Stage.TOOL");
diff -u -r -x pom.xml -x .svn -x .project -x .settings /home/stuart/Code/guice-vanilla/src/com/google/inject/internal/MatcherAndConverter.java ./src/com/google/inject/internal/MatcherAndConverter.java
--- /home/stuart/Code/guice-vanilla/src/com/google/inject/internal/MatcherAndConverter.java	2010-02-16 14:31:43.252978300 +0800
+++ ./src/com/google/inject/internal/MatcherAndConverter.java	2010-02-16 13:34:54.031978000 +0800
@@ -1,56 +0,0 @@
-/*
- * Copyright (C) 2007 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.inject.internal;
-
-import com.google.inject.TypeLiteral;
-import static com.google.inject.internal.Preconditions.checkNotNull;
-import com.google.inject.matcher.Matcher;
-import com.google.inject.spi.TypeConverter;
-
-/**
- * @author crazybob@google.com (Bob Lee)
- */
-final class MatcherAndConverter {
-
-  private final Matcher<? super TypeLiteral<?>> typeMatcher;
-  private final TypeConverter typeConverter;
-  private final Object source;
-
-  public MatcherAndConverter(Matcher<? super TypeLiteral<?>> typeMatcher,
-      TypeConverter typeConverter, Object source) {
-    this.typeMatcher = checkNotNull(typeMatcher, "type matcher");
-    this.typeConverter = checkNotNull(typeConverter, "converter");
-    this.source = source;
-  }
-
-  public TypeConverter getTypeConverter() {
-    return typeConverter;
-  }
-
-  public Matcher<? super TypeLiteral<?>> getTypeMatcher() {
-    return typeMatcher;
-  }
-
-  public Object getSource() {
-    return source;
-  }
-
-  @Override public String toString() {
-    return typeConverter + " which matches " + typeMatcher
-        + " (bound at " + source + ")";
-  }
-}
diff -u -r -x pom.xml -x .svn -x .project -x .settings /home/stuart/Code/guice-vanilla/src/com/google/inject/internal/ProxyFactory.java ./src/com/google/inject/internal/ProxyFactory.java
--- /home/stuart/Code/guice-vanilla/src/com/google/inject/internal/ProxyFactory.java	2010-02-16 14:31:43.158978300 +0800
+++ ./src/com/google/inject/internal/ProxyFactory.java	2010-02-16 13:33:58.923978000 +0800
@@ -17,6 +17,8 @@
 package com.google.inject.internal;
 
 import static com.google.inject.internal.BytecodeGen.newFastClass;
+
+import com.google.inject.ProvisionException;
 import com.google.inject.spi.InjectionPoint;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
@@ -153,10 +155,14 @@
 
     // Create the proxied class. We're careful to ensure that all enhancer state is not-specific
     // to this injector. Otherwise, the proxies for each injector will waste PermGen memory
+    try {
     Enhancer enhancer = BytecodeGen.newEnhancer(declaringClass, visibility);
     enhancer.setCallbackFilter(new IndicesCallbackFilter(declaringClass, methods));
     enhancer.setCallbackTypes(callbackTypes);
     return new ProxyConstructor<T>(enhancer, injectionPoint, callbacks, interceptors);
+    } catch (Throwable e) {
+      throw new ProvisionException("Unable to method intercept: " + declaringClass, e);
+  }
   }
 
   private static class MethodInterceptorsPair {
diff -u -r -x pom.xml -x .svn -x .project -x .settings /home/stuart/Code/guice-vanilla/src/com/google/inject/internal/SingleMethodInjector.java ./src/com/google/inject/internal/SingleMethodInjector.java
--- /home/stuart/Code/guice-vanilla/src/com/google/inject/internal/SingleMethodInjector.java	2010-02-16 14:31:43.202978300 +0800
+++ ./src/com/google/inject/internal/SingleMethodInjector.java	2010-02-16 13:33:58.944978000 +0800
@@ -23,6 +23,8 @@
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 
+import net.sf.cglib.core.CodeGenerationException;
+
 /**
  * Invokes an injectable method.
  */
@@ -45,6 +47,7 @@
     int modifiers = method.getModifiers();
     if (!Modifier.isPrivate(modifiers) && !Modifier.isProtected(modifiers)) {
       /*if[AOP]*/
+      try {
       final net.sf.cglib.reflect.FastMethod fastMethod
           = BytecodeGen.newFastClass(method.getDeclaringClass(), Visibility.forMember(method))
               .getMethod(method);
@@ -55,6 +58,10 @@
           return fastMethod.invoke(target, parameters);
         }
       };
+      } catch (CodeGenerationException e) {
+        // FastMethod failed: make accessible before reverting to JDK reflection
+        method.setAccessible(true);
+      }
       /*end[AOP]*/
     }
 
diff -u -r -x pom.xml -x .svn -x .project -x .settings /home/stuart/Code/guice-vanilla/src/com/google/inject/internal/State.java ./src/com/google/inject/internal/State.java
--- /home/stuart/Code/guice-vanilla/src/com/google/inject/internal/State.java	2010-02-16 14:31:43.479978300 +0800
+++ ./src/com/google/inject/internal/State.java	2010-02-16 13:34:54.153978000 +0800
@@ -20,6 +20,7 @@
 import com.google.inject.Key;
 import com.google.inject.Scope;
 import com.google.inject.TypeLiteral;
+import com.google.inject.spi.TypeConverterBinding;
 import com.google.inject.spi.TypeListenerBinding;
 import java.lang.annotation.Annotation;
 import java.util.List;
@@ -58,17 +59,17 @@
       throw new UnsupportedOperationException();
     }
 
-    public void addConverter(MatcherAndConverter matcherAndConverter) {
+    public void addConverter(TypeConverterBinding typeConverterBinding) {
       throw new UnsupportedOperationException();
     }
 
-    public MatcherAndConverter getConverter(String stringValue, TypeLiteral<?> type, Errors errors,
+    public TypeConverterBinding getConverter(String stringValue, TypeLiteral<?> type, Errors errors,
         Object source) {
       throw new UnsupportedOperationException();
     }
 
-    public Iterable<MatcherAndConverter> getConvertersThisLevel() {
-      return ImmutableSet.of();
+    public List<TypeConverterBinding> getConvertersThisLevel() {
+      return ImmutableList.of();
     }
 
     /*if[AOP]*/
@@ -120,14 +121,14 @@
 
   void putAnnotation(Class<? extends Annotation> annotationType, Scope scope);
 
-  void addConverter(MatcherAndConverter matcherAndConverter);
+  void addConverter(TypeConverterBinding typeConverterBinding);
 
   /** Returns the matching converter for {@code type}, or null if none match. */
-  MatcherAndConverter getConverter(
+  TypeConverterBinding getConverter(
       String stringValue, TypeLiteral<?> type, Errors errors, Object source);
 
   /** Returns all converters at this level only. */
-  Iterable<MatcherAndConverter> getConvertersThisLevel();
+  List<TypeConverterBinding> getConvertersThisLevel();
 
   /*if[AOP]*/
   void addMethodAspect(MethodAspect methodAspect);
diff -u -r -x pom.xml -x .svn -x .project -x .settings /home/stuart/Code/guice-vanilla/src/com/google/inject/internal/TypeConverterBindingProcessor.java ./src/com/google/inject/internal/TypeConverterBindingProcessor.java
--- /home/stuart/Code/guice-vanilla/src/com/google/inject/internal/TypeConverterBindingProcessor.java	2010-02-16 14:31:43.428978300 +0800
+++ ./src/com/google/inject/internal/TypeConverterBindingProcessor.java	2010-02-16 13:34:54.130978000 +0800
@@ -159,12 +159,12 @@
   private void internalConvertToTypes(Matcher<? super TypeLiteral<?>> typeMatcher,
       TypeConverter converter) {
     injector.state.addConverter(
-        new MatcherAndConverter(typeMatcher, converter, SourceProvider.UNKNOWN_SOURCE));
+        new TypeConverterBindingImpl(SourceProvider.UNKNOWN_SOURCE, typeMatcher, converter));
   }
 
   @Override public Boolean visit(TypeConverterBinding command) {
-    injector.state.addConverter(new MatcherAndConverter(
-        command.getTypeMatcher(), command.getTypeConverter(), command.getSource()));
+    injector.state.addConverter(new TypeConverterBindingImpl(
+        command.getSource(), command.getTypeMatcher(), command.getTypeConverter()));
     return true;
   }
 }
diff -u -r -x pom.xml -x .svn -x .project -x .settings /home/stuart/Code/guice-vanilla/src/com/google/inject/spi/ConvertedConstantBinding.java ./src/com/google/inject/spi/ConvertedConstantBinding.java
--- /home/stuart/Code/guice-vanilla/src/com/google/inject/spi/ConvertedConstantBinding.java	2010-02-16 14:31:42.879978300 +0800
+++ ./src/com/google/inject/spi/ConvertedConstantBinding.java	2010-02-16 13:34:53.827978000 +0800
@@ -35,6 +35,11 @@
   T getValue();
 
   /**
+   * Returns the type converter binding used to convert the constant.
+   */
+  TypeConverterBinding getTypeConverterBinding();
+
+  /**
    * Returns the key for the source binding. That binding can e retrieved from an injector using
    * {@link com.google.inject.Injector#getBinding(Key) Injector.getBinding(key)}.
    */
diff -u -r -x pom.xml -x .svn -x .project -x .settings /home/stuart/Code/guice-vanilla/src/com/google/inject/spi/Elements.java ./src/com/google/inject/spi/Elements.java
--- /home/stuart/Code/guice-vanilla/src/com/google/inject/spi/Elements.java	2010-02-16 14:31:42.818978300 +0800
+++ ./src/com/google/inject/spi/Elements.java	2010-02-16 13:34:53.802978000 +0800
@@ -37,6 +37,8 @@
 import com.google.inject.internal.Errors;
 import com.google.inject.internal.ImmutableList;
 import com.google.inject.internal.Lists;
+import com.google.inject.internal.TypeConverterBindingImpl;
+
 import static com.google.inject.internal.Preconditions.checkArgument;
 import com.google.inject.internal.PrivateElementsImpl;
 import com.google.inject.internal.ProviderMethodsModule;
@@ -278,7 +280,7 @@
 
     public void convertToTypes(Matcher<? super TypeLiteral<?>> typeMatcher,
         TypeConverter converter) {
-      elements.add(new TypeConverterBinding(getSource(), typeMatcher, converter));
+      elements.add(new TypeConverterBindingImpl(getSource(), typeMatcher, converter));
     }
 
     public RecordingBinder withSource(final Object source) {
diff -u -r -x pom.xml -x .svn -x .project -x .settings /home/stuart/Code/guice-vanilla/src/com/google/inject/spi/TypeConverterBinding.java ./src/com/google/inject/spi/TypeConverterBinding.java
--- /home/stuart/Code/guice-vanilla/src/com/google/inject/spi/TypeConverterBinding.java	2010-02-16 14:31:42.924978300 +0800
+++ ./src/com/google/inject/spi/TypeConverterBinding.java	2010-02-16 13:34:53.851978000 +0800
@@ -18,7 +18,6 @@
 
 import com.google.inject.TypeLiteral;
 import com.google.inject.Binder;
-import static com.google.inject.internal.Preconditions.checkNotNull;
 import com.google.inject.matcher.Matcher;
 
 /**
@@ -31,35 +30,15 @@
  * @author jessewilson@google.com (Jesse Wilson)
  * @since 2.0
  */
-public final class TypeConverterBinding implements Element {
-  private final Object source;
-  private final Matcher<? super TypeLiteral<?>> typeMatcher;
-  private final TypeConverter typeConverter;
-
-  TypeConverterBinding(Object source, Matcher<? super TypeLiteral<?>> typeMatcher,
-      TypeConverter typeConverter) {
-    this.source = checkNotNull(source, "source");
-    this.typeMatcher = checkNotNull(typeMatcher, "typeMatcher");
-    this.typeConverter = checkNotNull(typeConverter, "typeConverter");
-  }
-
-  public Object getSource() {
-    return source;
-  }
-
-  public Matcher<? super TypeLiteral<?>> getTypeMatcher() {
-    return typeMatcher;
-  }
-
-  public TypeConverter getTypeConverter() {
-    return typeConverter;
-  }
-
-  public <T> T acceptVisitor(ElementVisitor<T> visitor) {
-    return visitor.visit(this);
-  }
-
-  public void applyTo(Binder binder) {
-    binder.withSource(getSource()).convertToTypes(typeMatcher, typeConverter);
-  }
+public interface TypeConverterBinding extends Element {
+
+  Object getSource();
+
+  Matcher<? super TypeLiteral<?>> getTypeMatcher();
+
+  TypeConverter getTypeConverter();
+
+  <T> T acceptVisitor(ElementVisitor<T> visitor);
+
+  void applyTo(Binder binder);
 }
